# Conversion from float to double 
# IEEE 754 compliant

[require]
GLSL >= 1.30

[vertex shader]
void main()
{
    gl_Position = gl_Vertex;
}

[fragment shader]
/* Packs the sign `zSign', the exponent `zExp', and the significand formed by
 * the concatenation of `zFrac0' and `zFrac1' into a double-precision floating-
 * point value, returning the result.  After being shifted into the proper
 * positions, the three fields `zSign', `zExp', and `zFrac0' are simply added
 * together to form the most significant 32 bits of the result.  This means
 * that any integer portion of `zFrac0' will be added into the exponent.  Since
 * a properly normalized significand will have an integer portion equal to 1,
 * the `zExp' input should be 1 less than the desired result exponent whenever
 * `zFrac0' and `zFrac1' concatenated form a complete, normalized significand.
 */
uvec2 packFloat64( uint zSign, uint zExp, uint zFrac0, uint zFrac1 )
{
    uvec2 z;

    z.x = zFrac1;
    z.y = ( zSign<<31 ) + ( zExp<<20 ) + zFrac0;
    return z;
}

/* Returns the number of leading 0 bits before the most-significant 1 bit of
 * `a'.  If `a' is zero, 32 is returned.
 */
uint countLeadingZeros32( uint a )
{
    static const int8 countLeadingZerosHigh[] = {
        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    uint shiftCount;

    shiftCount = 0;
    if ( a < 0x10000 ) {
        shiftCount += 16;
        a <<= 16;
    }
    if ( a < 0x1000000 ) {
        shiftCount += 8;
        a <<= 8;
    }
    shiftCount += countLeadingZerosHigh[ a>>24 ];
    return shiftCount;
}

/* Normalizes the subnormal single-precision floating-point value represented
 * by the denormalized significand `aFrac'.  The normalized exponent and
 * significand are stored at the locations pointed to by `zExpPtr' and
 * `zFracPtr', respectively.
 */
void normalizeFloat32Subnormal( uint aFrac, uint *zExpPtr, uint *zFracPtr )
{
    uint shiftCount;

    shiftCount = countLeadingZeros32( aFrac ) - 8;
    *zFracPtr = aFrac<<shiftCount;
    *zExpPtr = 1 - shiftCount;
}

/* Returns the fraction bits of the single-precision floating-point value `a'.*/
uint extractFloat32Frac( uint a )
{
    return a & 0x007FFFFF;
}

/* Returns the exponent bits of the single-precision floating-point value `a'.*/
uint extractFloat32Exp( uint a )
{
    return (a>>23) & 0xFF;
}

/* Returns the sign bit of the single-precision floating-point value `a'.*/
uint extractFloat32Sign( uint a )
{
    return a>>31;
}

/* Returns the result of converting the single-precision floating-point value
 * `a' to the double-precision floating-point format.
 */
uvec2 fp32_to_fp64( uint a )
{
    uint aFrac;
    uint aExp;
    uint aSign;

    aFrac = extractFloat32Frac( a );
    aExp = extractFloat32Exp( a );
    aSign = extractFloat32Sign( a );
   
    if (aExp == 0xFF) {
        if ( aFrac ) {
            /* NaN */
            return uvec2(
                ( ( aSign<<31 ) | 0x7FF00000 | ( aFrac>>3 ) ),
                ( aFrac<<29 )
            );
        }
        /* Inf */
        return packFloat64( aSign, 0x7FF, 0, 0) );
    }

    if ( aExp == 0 ) {
        if ( aFrac ) {
            /* Denormals */
            normalizeFloat32Subnormal( aFrac, &aExp, &aFrac );
            --aExp;
        }
    /* Zero */
    return packFloat64( aSign, 0, 0, 0 );
    }

    return packFloat64( aSign, aExp + 0x380, aFrac>>3, aFrac<<29 );
}

uniform uint a;
uniform uvec2 expected;

void main()
{
    /* Generate green if the expected value is producted, red
     * otherwise.
     */
    gl_FragColor = fp32_to_fp64(a) == expected
        ? vec4(0.0, 1.0, 0.0, 1.0)
        : vec4(1.0, 0.0, 0.0, 1.0);
}

[test]
# A bunch of tests to run.  The 'uniform' lines set the uniforms.  The
# 'draw rect' line draws a rectangle that covers the whole window.
# The 'probe all' line verifies that every pixel contains the expected
# color.

# Try +0.0
uniform uint a         0x00000000
uniform uvec2 expected 0x00000000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0

# Try -0.0
uniform uint a         0x80000000
uniform uvec2 expected 0x80000000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0

# Try +Inf
uniform uint a         0x7F800000
uniform uvec2 expected 0x7FF00000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0

# Try -Inf
uniform uint a         0x7F800000
uniform uvec2 expected 0x7FF00000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0
