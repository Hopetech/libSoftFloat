# Conversion from float to double 
# IEEE 754 compliant

[require]
GLSL >= 1.30

[vertex shader]
void main()
{
    gl_Position = gl_Vertex;
}

[fragment shader]
/* Packs the sign `aSign', exponent `aExp', and fraction `aFrac' into a
 * double-precision floating-point value, returning the result.  After being
 * shifted into the proper positions, the three fields are simply added
 * together to form the result.
 */
uvec2 packFloat64( uint aSign, uint aExp, uvec2 aFrac )
{
    return uvec2(aSign + (aExp << 20) + aFrac.x, aFrac.y);
}

/* Returns the number of leading 0 bits before the most-significant 1 bit of
 * `a'.  If `a' is zero, 32 is returned.
 */
uint countLeadingZeros32( uint a )
{
    static const int8 countLeadingZerosHigh[] = {
        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    uint shiftCount;

    shiftCount = 0;
    if ( a < 0x10000 ) {
        shiftCount += 16;
        a <<= 16;
    }
    if ( a < 0x1000000 ) {
        shiftCount += 8;
        a <<= 8;
    }
    shiftCount += countLeadingZerosHigh[ a>>24 ];
    return shiftCount;
}

/* Normalizes the subnormal single-precision floating-point value represented
 * by the denormalized significand `aFrac'.  The normalized exponent and
 * significand are stored at the locations pointed to by `zExpPtr' and
 * `zFracPtr', respectively.
 */
void normalizeFloat32Subnormal( uint aFrac, uint *zExpPtr, uint *zFracPtr )
{
    uint shiftCount;

    shiftCount = countLeadingZeros32( aFrac ) - 8;
    *zFracPtr = aFrac<<shiftCount;
    *zExpPtr = 1 - shiftCount;
}

/* Returns the fraction bits of the single-precision floating-point value `a'.*/
uint extractFloat32Frac( uint a )
{
    return a & 0x007FFFFF;
}

/* Returns the exponent bits of the single-precision floating-point value `a'.*/
uint extractFloat32Exp( uint a )
{
    return (a>>23) & 0xFF;
}

/* Returns the sign bit of the single-precision floating-point value `a'.*/
uint extractFloat32Sign( uint a )
{
    return a & 0x80000000;
}

/* Returns the result of converting the single-precision floating-point value
 * `a' to the double-precision floating-point format.
 */
uvec2 fp32_to_fp64( uint a )
{
    uint aFrac;
    uint aExp;
    uint aSign;

    aFrac = extractFloat32Frac( a );
    aExp = extractFloat32Exp( a );
    aSign = extractFloat32Sign( a );
   
    if(aExp == 0xFF) {
        if( aFrac ) {
            /* NaN */
            return uvec2( (aSign | 0x7FF00000 | (aFrac>>3)), (aFrac<<29) );
        }
        /* Inf */
        return packFloat64( aSign, 0x7FF, uvec2(0,0) );
    }

    if( aExp == 0 ) {
        if( aFrac ) {
            /* Denormals */
            normalizeFloat32Subnormal( aFrac, &aExp, &aFrac );
            --aExp;
        }
    /* Zero */
    return packFloat64( aSign, 0, uvec2(0,0) );
    }

    return packFloat64( aSign, aExp + 0x380, uvec2( aFrac>>3, aFrac<<29 );
}

uniform uint a;
uniform uvec2 expected;

void main()
{
    /* Generate green if the expected value is producted, red
     * otherwise.
     */
    gl_FragColor = fp32_to_fp64(a) == expected
        ? vec4(0.0, 1.0, 0.0, 1.0)
        : vec4(1.0, 0.0, 0.0, 1.0);
}

[test]
# A bunch of tests to run.  The 'uniform' lines set the uniforms.  The
# 'draw rect' line draws a rectangle that covers the whole window.
# The 'probe all' line verifies that every pixel contains the expected
# color.

# Try +0.0
uniform uint a         0x00000000
uniform uvec2 expected 0x00000000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0

# Try -0.0
uniform uint a         0x80000000
uniform uvec2 expected 0x80000000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0

# Try +Inf
uniform uint a         0x7F800000
uniform uvec2 expected 0x7FF00000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0

# Try -Inf
uniform uint a         0x7F800000
uniform uvec2 expected 0x7FF00000 0x00000000
draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0
